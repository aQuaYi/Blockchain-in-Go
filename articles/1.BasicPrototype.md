# Building Blockchain in Go. Part 1: Basic Prototype åˆ©ç”¨ Go æ„å»ºåŒºå—é“¾ã€‚ç¬¬ 1 éƒ¨åˆ†ï¼šåŸºæœ¬æ¡†æ¶

AUGUST 16, 2017
2017å¹´08æœˆ16æ—¥

[GOLANG BLOCKCHAIN BITCOIN](https://jeiwan.cc/tags/blockchain)

## Introduction ç®€ä»‹

Blockchain is one of the most revolutionary technologies of the 21st century, which is still maturing and which potential is not fully realized yet. In its essence, blockchain is just a distributed database of records. But what makes it unique is that itâ€™s not a private database, but a public one, i.e. everyone who uses it has a full or partial copy of it. And a new record can be added only with a consent of other keepers of the database. Also, itâ€™s blockchain that made cryptocurrencies and smart contracts possible.

åŒºå—é“¾æ˜¯ 21 ä¸–çºªæœ€å…·é©å‘½æ€§çš„ç§‘æŠ€ä¹‹ä¸€ï¼Œä»–ä¾ç„¶åœ¨é«˜é€Ÿå‘å±•é˜¶æ®µï¼Œæ²¡æœ‰é‡Šæ”¾å…¶å…¨éƒ¨æ½œåŠ›ã€‚æœ¬è´¨ä¸Šï¼ŒåŒºå—é“¾æ˜¯åˆ†å¸ƒå¼æ•°æ®åº“ä¸­çš„ä¸€ç§ã€‚è€Œå…¶ä¸ä¼—ä¸åŒçš„ç‰¹æ€§æ˜¯ï¼Œä»–ä¸æ˜¯ä¸€ä¸ªç§æœ‰æ•°æ®åº“ï¼Œè€Œæ˜¯å…¬å¼€çš„ï¼Œä¾‹å¦‚ï¼Œæ¯ä¸ªç”¨æˆ·éƒ½æ‹¥æœ‰å®Œæ•´æˆ–éƒ¨åˆ†çš„æ•°æ®å¤‡ä»½ã€‚ä¸æ­¤åŒæ—¶ï¼Œåªæœ‰åœ¨å…¶ä»–æ•°æ®åº“ç”¨æˆ·åŒæ„çš„å‰æä¸‹ï¼Œæ‰èƒ½å¾€æ•°æ®åº“ä¸­æ·»åŠ æ•°æ®ã€‚æœ€åï¼ŒåŒºå—é“¾ä½¿å¾—åŠ å¯†è´§å¸å’Œæ™ºèƒ½åˆçº¦æˆä¸ºå¯èƒ½ã€‚

In this series of articles weâ€™ll build a simplified cryptocurrency thatâ€™s based on a simple blockchain implementation.

åœ¨æœ¬ç³»åˆ—æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸€æ¡ç®€åŒ–åçš„åŒºå—é“¾ä¸Šï¼Œæ„å»ºä¸€ä¸ªç®€å•çš„åŠ å¯†è´§å¸ã€‚

## Block åŒºå—

Letâ€™s start with the â€œblockâ€ part of â€œblockchainâ€. In blockchain itâ€™s blocks that store valuable information. For example, bitcoin blocks store transactions, the essence of any cryptocurrency. Besides this, a block contains some technical information, like its version, current timestamp and the hash of the previous block.

è®©æˆ‘ä»¬ä»â€œåŒºå—é“¾â€çš„â€œåŒºå—â€å¼€å§‹ã€‚åŒºå—ç”¨äºå­˜åœ¨æœ‰ä»·å€¼çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œæ¯”ç‰¹å¸åŒºå—ä¸­ä¿å­˜äº†äº¤æ˜“ä¿¡æ¯ï¼Œè¿™æ˜¯æ‰€æœ‰åŠ å¯†è´§å¸çš„åŸºæœ¬åŠŸèƒ½ã€‚æ­¤å¤–ï¼ŒåŒºå—ä¸­å‚¨å­˜äº†ä¸€äº›ç»§ç»­ä¿¡æ¯ï¼Œæ¯”å¦‚åŒºå—é“¾çš„ç‰ˆæœ¬å·ï¼ŒåŒºå—ç”Ÿæˆçš„æ—¶é—´æˆ³å’Œå‰ä¸€ä¸ªåŒºå—çš„ hash åœ°å€ã€‚

In this article weâ€™re not going to implement the block as itâ€™s described in blockchain or Bitcoin specifications, instead weâ€™ll use a simplified version of it, which contains only significant information. Hereâ€™s what it looks like:

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¸å‡†å¤‡å»æ„å»ºåŒºå—é“¾æˆ–æ¯”ç‰¹å¸æ‰€éœ€çš„é‚£ç§åŒºå—ï¼Œæˆ‘ä»¬ä¼šä»¥ä¸€ç§ç®€åŒ–ç‰ˆçš„åŒºå—å–è€Œä»£ä¹‹ã€‚è¿™ç§ç®€åŒ–çš„åŒºå—åªä¼šåŒ…å«æœ€é‡è¦çš„ä¿¡æ¯ï¼Œä»–ä»¬é•¿ä¸‹é¢è¿™æ ·ï¼š

```go
type Block struct {
    Timestamp     int64
    Data          []byte
    PrevBlockHash []byte
    Hash          []byte
}
```

`Timestamp` is the current timestamp (when the block is created), `Data` is the actual valuable information containing in the block, `PrevBlockHash` stores the hash of the previous block, and `Hash` is the hash of the block. In Bitcoint specification `Timestamp`, `PrevBlockHash`, and `Hash` are block headers, which form a separate data structure, and transactions (`Data` in our case) is a separate data structure. So weâ€™re mixing them here for simplicity.

`Timestamp` è®°å½•äº†åˆ›å»ºåŒºå—çš„æ—¶é—´ã€‚`Data`åŒ…å«äº†åŒºå—ä¸­çœŸæ­£é‡è¦çš„ä¿¡æ¯ã€‚`PrevBlockHash` è®°å½•äº†ä¸Šä¸€ä¸ªåŒºå—çš„ hash åœ°å€ã€‚`Hash` æ˜¯è¿™ä¸ªåŒºå—çš„ hash å€¼ã€‚åœ¨æ¯”ç‰¹å¸è§„èŒƒä¸­ï¼Œ`Timestamp`, `PrevBlockHash` å’Œ `Hash` ä½œä¸ºåŒºå—çš„å¤´éƒ¨ä¿¡æ¯ï¼Œä¿å­˜åœ¨å¦ä¸€ä¸ªç»“æ„ä½“ä¸­ï¼Œä¸ä¸äº¤æ˜“è®°å½•ï¼ˆæ­¤æ—¶ä¾‹å­ä¸­çš„`Data`ï¼‰ä¿å­˜åœ¨åŒä¸€ä¸ªæ•°æ®ç»“æ„ä¸­ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¸ºäº†ç®€ä¾¿ï¼ŒæŠŠä»–ä»¬æ··åˆåœ¨ä¸€èµ·äº†ã€‚

So how do we calculate the hashes? The way hashes are calculates is very important feature of blockchain, and itâ€™s this feature that makes blockchain secure. The thing is that calculating a hash is a computationally difficult operation, it takes some time even on fast computers (thatâ€™s why people buy powerful GPUs to mine Bitcoin). This is an intentional architectural design, which makes adding new blocks difficult, thus preventing their modification after theyâ€™re added. Weâ€™ll discuss and implement this mechanism in a future article.

é‚£è¦å¦‚ä½•è®¡ç®— hash å€¼å‘¢ï¼Ÿhash å€¼çš„è®¡ç®—æ–¹å¼æ˜¯åŒºå—é“¾çš„é‡è¦ç‰¹å¾ï¼Œæ˜¯ä¿è¯åŒºå—é“¾å®‰å…¨çš„é€”å¾„ã€‚è®¡ç®— hash éœ€è¦ç»è¿‡ç¹ççš„è¿ç®—ï¼Œå³ä½¿åœ¨é«˜æ€§èƒ½çš„ç”µè„‘ä¸Šï¼Œä¹Ÿä¼šèŠ±è´¹å¾ˆå¤šæ—¶é—´ï¼ˆè¿™å°±æ˜¯äººä»¬é‡‡è´­é«˜æ€§èƒ½æ˜¾å¡æŒ–æ˜æ¯”ç‰¹å¸çš„åŸå› ï¼‰ã€‚è¿™æ˜¯ä¸ºäº†å¢åŠ ç”Ÿæˆæ–°å—çš„éš¾åº¦ï¼Œæ•…æ„é‡‡å–è¿™æ ·çš„ç»“æ„è®¾è®¡ã€‚è¿˜å¯ä»¥æœ‰æ•ˆé˜»æ­¢å·²ç»ç”Ÿæˆçš„åŒºå—è¢«ä¿®æ”¹ã€‚åœ¨æœªæ¥çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä¼šæ¢è®¨å¹¶å®ç°è¿™ç§æœºåˆ¶ã€‚

For now, weâ€™ll just take block fields, concatenate them, and calculate a SHA-256 hash on the concatenated combination. Letâ€™s do this in SetHash method:

æ­¤åˆ»ï¼Œæˆ‘ä»¬åªå…³å¿ƒ block ä¸­çš„å±æ€§ï¼Œè¿ç»“ä»–ä»¬ï¼Œå¹¶è®¡ç®—è¿ç»“åçš„ SHA-256 hash å€¼ã€‚å…·ä½“åšæ³•ï¼Œå‚è§ä»¥ä¸‹çš„ SetHash æ–¹æ³•ï¼š

```go
func (b *Block) SetHash() {
    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))
    headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})
    hash := sha256.Sum256(headers)

    b.Hash = hash[:]
}
```

Next, following a Golang convention, weâ€™ll implement a function thatâ€™ll simplify the creation of a block:

æ¥ä¸‹æ¥ï¼ŒæŒ‰ç…§ Go è¯­è¨€æƒ¯ä¾‹ï¼Œæˆ‘ä»¬ä¼šå®ç°ä¸€ä¸ªå‡½æ•°ï¼Œå»ç®€åŒ–åŒºå—çš„ç”Ÿæˆã€‚

```go
func NewBlock(data string, prevBlockHash []byte) *Block {
    block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}
    block.SetHash()
    return block
}
```

And thatâ€™s it for the block!

äºæ˜¯ï¼Œå°±å¾—åˆ°äº†åŒºå—ã€‚

## Blockchain

Now letâ€™s implement a blockchain. In its essence blockchain is just a database with certain structure: itâ€™s an ordered, back-linked list. Which means that blocks are stored in the insertion order and that each block is linked to the previous one. This structure allows to quickly get the latest block in a chain and to (efficiently) get a block by its hash.

ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥æ„å»ºä¸€ä¸ªåŒºå—é“¾ã€‚åŸºæœ¬ä¸Šï¼ŒåŒºå—é“¾æ˜¯ä¸€ä¸ªå…·æœ‰è¿™æ ·ç»“æ„çš„æ•°æ®åº“ï¼šæœ‰åºçš„åå‘é“¾æ¥åˆ—è¡¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰€æœ‰çš„åŒºå—ä»¥æ’å…¥çš„é¡ºåºå­˜å‚¨èµ·æ¥ï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªåŒºå—éƒ½é“¾æ¥åˆ°å‰ä¸€ä¸ªåŒºå—ã€‚è¿™ç§ç»“æ„å¯ä»¥å¿«é€Ÿåœ°è·å–æœ€æ–°çš„åŒºå—ï¼Œä¹Ÿå¯ä»¥ï¼ˆé«˜æ•ˆåœ°ï¼‰é€šè¿‡ hash å€¼æŸ¥æ‰¾åˆ°åŒºå—ã€‚

In Golang this structure can be implemented by using an array and a map: the array would keep ordered hashes (arrays are ordered in Go), and the map would keep hash â†’ block pairs (maps are unordered). But for our blockchain prototype weâ€™ll just use an array, because we donâ€™t need to get blocks by their hash for now.

åœ¨ Go è¯­è¨€ä¸­ï¼Œè¿™ç§ç»“æ„ï¼Œå¯ä»¥é€šè¿‡æ•°ç»„å’Œæ˜ å°„æ¥å®ç°ï¼šæ•°ç»„å¯ä»¥æŒ‰é¡ºåºä¿å­˜ hash å€¼ï¼ˆGo è¯­è¨€ä¸­çš„æ•°ç»„æ˜¯æœ‰åºçš„ï¼‰ï¼Œæ˜ å°„å¯ä»¥ç”¨æ¥ä¿å­˜åŒºå—å¯¹çš„ hash å€¼ï¼ˆæ˜ å°„æ˜¯æ— åºçš„ï¼‰ã€‚ä½†æ˜¯ï¼Œå¯¹äºæˆ‘ä»¬ç°åœ¨çš„åŒºå—é“¾åŸå‹æ¥è¯´ï¼Œåªä½¿ç”¨æ•°ç»„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦é€šè¿‡ hash å€¼æŸ¥æ‰¾åŒºå—ã€‚

```go
type Blockchain struct {
    blocks []*Block
}
```

This is our first blockchain! Iâ€™ve never thought it would be so easy ğŸ˜‰

è¿™æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€æ¡åŒºå—é“¾ï¼æˆ‘ä»æ²¡æƒ³è¿‡ä¼šå¦‚æ­¤è½»æ¾ã€‚

Now letâ€™s make it possible to add blocks to it:

ç°åœ¨ï¼Œè®©æˆ‘ä»¬èµ‹äºˆå®ƒæ·»åŠ åŒºå—çš„èƒ½åŠ›ï¼š

```go
func (bc *Blockchain) AddBlock(data string) {
    prevBlock := bc.blocks[len(bc.blocks)-1]
    newBlock := NewBlock(data, prevBlock.Hash)
    bc.blocks = append(bc.blocks, newBlock)
}
```

Thatâ€™s it! Or not?..

ææ‚ï¼æˆ–è€…è¿˜å·®ç‚¹ä»€ä¹ˆï¼Ÿ

To add a new block we need an existing block, but thereâ€™re not blocks in our blockchain! So, in any blockchain, there must be at least one block, and such block, the first in the chain, is called genesis block. Letâ€™s implement a method that creates such a block:

ä¸ºäº†æ·»åŠ åŒºå—éœ€è¦ä¸€ä¸ªå·²æœ‰çš„åŒºå—ï¼Œä½†æ˜¯æˆ‘ä»¬çš„åŒºå—é“¾ä¸­ï¼Œç°åœ¨æ˜¯ç©ºçš„ã€‚æ‰€ä»¥ï¼Œåœ¨ä»»ä½•åŒºå—é“¾ä¸­éƒ½è‡³å°‘å­˜åœ¨ä¸€ä¸ªåŒºå—ï¼Œè¿™æ ·çš„ä¸€ä¸ªåŒºå—ï¼Œå³åŒºå—é“¾ä¸­çš„ç¬¬ä¸€ä¸ªåŒºå—ï¼Œè¢«æˆä¸ºåˆ›ä¸–åŒºå—ã€‚è®©æˆ‘ä»¬å®ç°ä¸€ä¸ªæ–¹æ³•æ¥åˆ›é€ è¿™æ ·çš„ä¸€ä¸ªåŒºå—ã€‚

```go
func NewGenesisBlock() *Block {
    return NewBlock("Genesis Block", []byte{})
}
```

Now, we can implement a function that creates a blockchain with the genesis block:

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªå‡½æ•°æ¥æ¥åˆ©ç”¨åˆ›ä¸–åŒºå—åˆ›å»ºåŒºå—é“¾ã€‚

```go
func NewBlockchain() *Blockchain {
    return &Blockchain{[]*Block{NewGenesisBlock()}}
}
```

Letâ€™s check that the blockchain works correctly:

æ£€æŸ¥åŒºå—é“¾æ˜¯å¦èƒ½å¤Ÿæ­£å¸¸å·¥ä½œï¼š

```go
func main() {
    bc := NewBlockchain()

    bc.AddBlock("Send 1 BTC to Ivan")
    bc.AddBlock("Send 2 more BTC to Ivan")

    for _, block := range bc.blocks {
        fmt.Printf("Prev. hash: %x\n", block.PrevBlockHash)
        fmt.Printf("Data: %s\n", block.Data)
        fmt.Printf("Hash: %x\n", block.Hash)
        fmt.Println()
    }
}
```

Output:
è¾“å‡ºï¼š

```text
Prev. hash:
Data: Genesis Block
Hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168

Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168
Data: Send 1 BTC to Ivan
Hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1

Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1
Data: Send 2 more BTC to Ivan
Hash: 561237522bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1
```

Thatâ€™s it!
ææ‚ï¼

## Conclusion æ€»ç»“

We built a very simple blockchain prototype: itâ€™s just an array of blocks, with each block having a connection to the previous one. The actual blockchain is much more complex though. In our blockchain adding new blocks is easy and fast, but in real blockchain adding new blocks requires some work: one has to perform some heavy computations before getting a permission to add block (this mechanism is called Proof-of-Work). Also, blockchain is a distributed database that has no single decision maker. Thus, a new block must be confirmed and approved by other participants of the network (this mechanism is called consensus). And thereâ€™re no transactions in our blockchain yet!

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªéå¸¸ç®€å•çš„åŒºå—é“¾åŸå‹ï¼šç”±äºåŒºå—ç»„æˆçš„æ•°ç»„ï¼Œæ¯ä¸ªåŒºå—éƒ½èƒ½é“¾æ¥éƒ½å‰ä¸€ä¸ªåŒºå—ã€‚çœŸå®çš„åŒºå—é“¾æ˜¯å¤æ‚å¾—å¤šçš„æ„æ€ã€‚å¯ä»¥è½»æ¾å¿«é€Ÿåœ°åœ¨æˆ‘ä»¬çš„åŒºå—é“¾ä¸­ï¼Œæ·»åŠ åŒºå—ã€‚ä½†æ˜¯åœ¨çœŸå®çš„åŒºå—é“¾ä¸­æ·»åŠ æ–°çš„åŒºå—éœ€è¦å¹²ä¸€äº›å·¥ä½œï¼šåªæœ‰åœ¨è¿›è¡Œäº†ç¹é‡çš„è¿ç®—åï¼Œæ‰èƒ½è·å–æ·»åŠ æ–°åŒºå—çš„æƒé™ï¼ˆè¿™ç§æœºåˆ¶è¢«ç§°ä¸ºå·¥ä½œé‡è¯æ˜ï¼‰ã€‚å¦å¤–ï¼ŒåŒºå—é“¾æ˜¯æ²¡æœ‰å•ä¸€ä»²è£äººçš„åˆ†å¸ƒå¼æ•°æ®åº“ã€‚å› æ­¤ï¼Œä¸€ä¸ªæ–°çš„åŒºå—å¿…é¡»è¢«ç½‘ç»œä¸­çš„å…¶ä»–éƒ¨åˆ†ç¡®è®¤å’Œè®¤å¯æ‰è¡Œï¼ˆè¿™ç§æœºåˆ¶è¢«ç§°ä¸ºå…±è¯†ï¼‰ã€‚æœ€åï¼Œæˆ‘ä»¬çš„åŒºå—é“¾è¿˜æ²¡æœ‰äº¤æ˜“åŠŸèƒ½ã€‚

In future articles weâ€™ll cover each of these features.

åœ¨æœªæ¥çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä¼šè¦†ç›–åˆ°ä»¥ä¸Šæ‰€æœ‰ç‰¹æ€§ã€‚

------

Links:

- Full source codes: [https://github.com/Jeiwan/blockchain_go/tree/part_1](https://github.com/Jeiwan/blockchain_go/tree/part_1)
- Block hashing algorithm: [https://en.bitcoin.it/wiki/Block_hashing_algorithm](https://en.bitcoin.it/wiki/Block_hashing_algorithm)

// TODO: æ·»åŠ æˆ‘è‡ªå·±çš„é“¾æ¥
